helfer = require 'helfer'

typeHandlers =
  string: (parsed, value) ->
    return value
  bool: (parsed, value) ->
    unless value in ['true', 'false']
      throw new Error "env var #{parsed.envVarName} must be 'true' or 'false'"
    return value is 'true'
  int: (parsed, value) ->
    result = parseInt value, 10
    if isNaN result
      throw new Error "env var #{parsed.envVarName} must be an integer"
    return result
  float: (parsed, value) ->
    result = parseFloat value
    if isNaN result
      throw new Error "env var #{parsed.envVarName} must be a float"
    return result
  json: (parsed, value) ->
    try
      result = JSON.parse value
    catch e
      throw new Error "env var #{parsed.envVarName} must be json. syntax error `#{e.message}`"
    result

parse = (config, key) ->
  restWords = helfer.splitCamelcase key

  maybe = 0 is helfer.findIndexWhereSequence restWords, config.maybePrefixWordArray

  if maybe
    restWords = restWords.slice(config.maybePrefixWordArray.length)

  # prefix must be present right after maybe
  unless 0 is helfer.findIndexWhereSequence restWords, config.prefixWordArray
    return

  restWords = restWords.slice(config.prefixWordArray.length)

  index = -1
  length = config.typeNameWordArrays.length
  while ++index < length
    if -1 isnt helfer.findIndexWhereSequence restWords, config.typeNameWordArrays[index]
      typeWordArray = config.typeNameWordArrays[index]
      break

  # none of the registered types present
  unless typeWordArray
    return

  restWords = restWords.slice(typeWordArray.length)

  # no name present
  if restWords.length is 0
    return

  {
    maybe: maybe
    type: helfer.joinCamelcase typeWordArray
    name: helfer.joinCamelcase restWords
    envVarName: helfer.joinUppercaseUnderscore restWords
  }

optionsToConfig = (options) ->
  config = {}

  config.env = options.env or process.env

  config.prefixWordArray = helfer.splitCamelcase (options.prefix or 'env')
  config.maybePrefixWordArray = helfer.splitCamelcase (options.maybePrefix or 'maybe')

  config.typeHandlers = {}
  Object.keys(typeHandlers).forEach (key) ->
    config.typeHandlers[key] = typeHandlers[key]
  if options.typeHandlers?
    Object.keys(options.typeHandlers).forEach (key) ->
      config.typeHandlers[key] = options.typeHandlers[key]

  config.envDependencyName = options.envDependencyName or 'env'
  config.typeNameWordArrays = Object.keys(config.typeHandlers).map helfer.splitCamelcase
  return config

# this is a function that when called
# returns a source that when called
# returns a factory
configure = (options = {}) ->
  config = optionsToConfig options

  return (key) ->
    if key is config.envDependencyName
      # return a factory that resolves to the env
      return -> config.env

    parsed = parse config, key

    # we cant do anything
    unless parsed?
      return

    factory = (env) ->
      value = env[parsed.envVarName]
      if not value? or value is''
        if parsed.maybe
          return null
        else
          throw new Error "env var #{parsed.envVarName} must not be blank"

      config.typeHandlers[parsed.type](parsed, value)
    factory.__inject = [config.envDependencyName]
    factory.__source = 'generated by umgebung'
    factory.__parsed = parsed
    return factory

# export source preconfigured with defaults for convenience.
module.exports = configure()
# export configure as well for flexibility.
module.exports.configure = configure
# export helpers as well. for testing and because they might be useful on their own.
module.exports.parse = parse
