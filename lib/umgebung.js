// Generated by CoffeeScript 1.9.2
var configure, helfer, optionsToConfig, parse, typeHandlers;

helfer = require('helfer');

typeHandlers = {
  string: function(parsed, value) {
    return value;
  },
  bool: function(parsed, value) {
    if (value !== 'true' && value !== 'false') {
      throw new Error("env var " + parsed.envVarName + " must be 'true' or 'false'");
    }
    return value === 'true';
  },
  int: function(parsed, value) {
    var result;
    result = parseInt(value, 10);
    if (isNaN(result)) {
      throw new Error("env var " + parsed.envVarName + " must be an integer");
    }
    return result;
  },
  float: function(parsed, value) {
    var result;
    result = parseFloat(value);
    if (isNaN(result)) {
      throw new Error("env var " + parsed.envVarName + " must be a float");
    }
    return result;
  },
  json: function(parsed, value) {
    var e, result;
    try {
      result = JSON.parse(value);
    } catch (_error) {
      e = _error;
      throw new Error("env var " + parsed.envVarName + " must be json. syntax error `" + e.message + "`");
    }
    return result;
  }
};

parse = function(config, name) {
  var index, length, maybe, restWords, typeWordArray;
  restWords = helfer.splitCamelcase(name);
  maybe = 0 === helfer.findIndexWhereSequence(restWords, config.maybePrefixWordArray);
  if (maybe) {
    restWords = restWords.slice(config.maybePrefixWordArray.length);
  }
  if (0 !== helfer.findIndexWhereSequence(restWords, config.prefixWordArray)) {
    return;
  }
  restWords = restWords.slice(config.prefixWordArray.length);
  index = -1;
  length = config.typeNameWordArrays.length;
  while (++index < length) {
    if (-1 !== helfer.findIndexWhereSequence(restWords, config.typeNameWordArrays[index])) {
      typeWordArray = config.typeNameWordArrays[index];
      break;
    }
  }
  if (!typeWordArray) {
    return;
  }
  restWords = restWords.slice(typeWordArray.length);
  if (restWords.length === 0) {
    return;
  }
  return {
    maybe: maybe,
    type: helfer.joinCamelcase(typeWordArray),
    name: helfer.joinCamelcase(restWords),
    envVarName: helfer.joinUppercaseUnderscore(restWords)
  };
};

optionsToConfig = function(options) {
  var config;
  config = {};
  config.env = options.env || process.env;
  config.prefixWordArray = options.prefix != null ? helfer.splitCamelcase(options.prefix) : ['env'];
  config.maybePrefixWordArray = options.maybePrefix != null ? helfer.splitCamelcase(options.maybePrefix) : ['maybe'];
  config.typeHandlers = {};
  Object.keys(typeHandlers).forEach(function(key) {
    return config.typeHandlers[key] = typeHandlers[key];
  });
  if (options.typeHandlers != null) {
    Object.keys(options.typeHandlers).forEach(function(key) {
      return config.typeHandlers[key] = options.typeHandlers[key];
    });
  }
  config.envDependencyName = options.envDependencyName || 'env';
  config.typeNameWordArrays = Object.keys(config.typeHandlers).map(helfer.splitCamelcase);
  return config;
};

configure = function(options) {
  var config;
  if (options == null) {
    options = {};
  }
  config = optionsToConfig(options);
  return function(name) {
    var factory, parsed;
    if (name === config.envDependencyName) {
      return function() {
        return config.env;
      };
    }
    parsed = parse(config, name);
    if (parsed == null) {
      return;
    }
    factory = function(env) {
      var value;
      value = env[parsed.envVarName];
      if ((value == null) || value === '') {
        if (parsed.maybe) {
          return null;
        } else {
          throw new Error("env var " + parsed.envVarName + " must not be blank");
        }
      }
      return config.typeHandlers[parsed.type](parsed, value);
    };
    factory.__inject = [config.envDependencyName];
    factory.__source = 'generated by fragments-env';
    factory.__parsed = parsed;
    return factory;
  };
};

module.exports = configure();

module.exports.configure = configure;

module.exports.parse = parse;
